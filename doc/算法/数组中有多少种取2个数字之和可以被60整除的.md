### 数组中有多少种取2个数字之和可以被60整除的
```
// 示例 1：

// 输入：[30,20,150,100,40]
// 输出：3
// 示例 2：

// 输入：[60,60,60]
// 输出：3
//  

// 提示：

// 1 <= time.length <= 60000
// 1 <= time[i] <= 500
```
####  解题思路
-  我的理解是数组中有多少种取2个数字之和可以被60整除的
- 既然被60整除那余数肯定不可能超过60
- 首先，创建一个长度为60的数组，存储除以60的余数，其中key为余数，value为次数，举例：100%60 = 40 则数组为[40: 1]; 40 % 60 则数组为[40:2],这是一个累加的过程，当余数一样的情况直接value加1
- 紧接着，考虑。。。
- 2数之和？？？如果2数之和的余数相加等于60是否可以被整除？？ 回答是的。
- 那是不是考虑 数组种 key 1 可以和 key 59 的之和可以被60整除？？ 以此类推， key 2 和 key 58 ???
- 如果key 1 的value 为 2， key 59 的value 为 2 ，则有多少种组合方式？？？
- 很明显是n * n
 
- 直到 key 30 ??  这怎么处理？？
- key 0 尼？？
- 余数为0可以确定 本身可以被60整除，那2个余数为0的同样也可以对吧！！
- 假如余数为0 的 数组种有 [ 60, 120, 180] 
- 他们被60整除后会将余数保存到长度为60的数组种，这样key 0 的value 为 3 ！！
- 考虑如果他们2个2个相加有多少种组合方式？？  找出规律  为  （n-1）* n/2  （小学数学，无奈全还给老师了，哈哈！！）
- 举例 数组种 2 个被60整除的 则组合方式有1 种， 3个被整除的有 3 种， 4个被整除的 6种 。。。
- 上面说的key 30 的也是同样的道理 ，规律一样也是 （n-1）* n/2 
- 
- 最后把这几种情况全部加起来就是正确的结果

#### code
```javascript
/**
 * @param {number[]} time
 * @return {number}
 */
var numPairsDivisibleBy60 = function(time) {
    let n = time.length;
    if (time === null || n === 0) return 0;
    let count = new Array(60);
    for (let k = 0; k < 60; k++) {
        count[k] = 0;
    }
    for (let i = 0; i < n; i++) {
        count[time[i] % 60]++;
    }
    let result = 0;
    // （n-1）* n/2
    result += (count[0] - 1) * count[0]/ 2 + (count[30] - 1) * count[30] / 2;
    let i = 1;
    // n * n
    while(i <= 29) {
        result += count[i] * count[60-i];
        i++;
    }
    return result;
};
```