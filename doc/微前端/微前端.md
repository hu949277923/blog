
# 微前端

微前端架构是一种类似于微服务的架构，它将微服务的理念应用于浏览器端，即将 Web 应用由单一的单体应用转变为多个小型前端应用聚合为一的应用。
由此带来的变化是，这些前端应用可以独立运行、独立开发、独立部署。以及，它们应该可以在共享组件的同时进行并行开发——这些组件可以通过 NPM私有仓库 来管理。

下面就之前项目的实现方案进行简单介绍：核心实现原理是基于Http服务器反向代理实现。

之前各个子应用分别配置子域名，如app1为app1.vipkid.com、app2.vipkid.com、sso.vipkid.com等。

![](https://thumbnail0.baidupcs.com/thumbnail/9d6b197bak093eb36701315f2289e1c8?fid=357033652-250528-79860166325178&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-F%2fgH9YUl6nnl31dLFMmnKnHhSmQ%3d&expires=8h&chkbd=0&chkv=0&dp-logid=5558130551022862147&dp-callid=0&time=1598511600&size=c1440_u900&quality=90&vuk=357033652&ft=image&autopolicy=1)

## 单点登录

sso.vipkid.com主要是单点登录，在未登录的情况下访问各个子应用时会将当前子应用url地址带上跳转到sso.vipkid.com，登录成功后会重定向到对应子应用模块，在访问其他子应用时无需重新登录。实现原理:登录成功后会在主域名.vipkid.com的cookie中种下token；跳转到子域名调用判断是否登录接口，因为子域名会携带主域名的cookie，故后端直接获取cookie的token进行认证就可以；如果成功后直接再获取用户及权限等相关的信息。为了避免每次访问子系统都请求释放登录接口，可以在首次判断后获取到token直接存储到本地，下次进入先获取本地token，再获取cookie中token进行比较如果一致则证明是有效token直接使用即可，否则清除用户及权限相关信息然后重定向至登录页

## npm私有仓库

各个子应用中的公共组件由npm私有仓库（暂且为npm.300.cn）进行统一管理，实现npm与gitlab集成。现阶段项目完全依赖www.npmjs.com,如果后期他们停止维护，或者项目中用到的依赖包被删或者植入木马等，我们会很被动，我了解的解决方案就是项目涉及到的依赖包全部优先通过npm.300.cn获取，这样会避免这个问题。因为npm.300.cn会在初始化时，像前端用到的如vue-cli、vue-router，并没有进行同步；我们在首次install时，会优先拉取www.npmjs.com，然后将用到的包同步到npm.300.cn，这样我们在下次使用时就无需再去www.npmjs.com拉取。npm.300.cn会将我们项目中用到的依赖包进行同步，无需强依赖第三方（www.npmjs.com）

## 路由分发

路由分发式微前端，即通过路由将不同的业务分发到不同的、独立前端应用上。其通常可以通过 HTTP 服务器的反向代理来实现，又或者是应用框架自带的路由来解决。
就之前而言，是采用路由分发式的微前端架构。但是这种方式看上去更像是多个前端应用的聚合，即我们只是将这些不同的前端应用拼凑到一起，使他们看起来像是一个完整的整体。但是它们并不是，每次用户从 A 应用到 B 应用的时候，往往需要刷新一下页面。

## frame

此frame并不算iframe的那种实现方案。frame是导航侧边栏，要注意的是导航是各个子系统都会引入的，frame对外暴漏一个参数menu，各个子系统通过menu来定义自己的导航及侧边栏；之前项目中会定义menu时，将所有页面的权限码进行配置，然后在frame中遍历时，通过接口或者已经存在本地的权限列表去判断是否存在menu中对应页面的权限码，从而将没有权限的导航进行过滤，除此之外，通过url访问原理也一样，在router的meta属性中配置来对应的权限，我么在router.beforeEach中获取当前访问的权限码后再去判断是否有此权限。

## 跨应用之间跳转

所有的应用有一个共享文件如util，里面配置各个子应用的域名或者代理的地址路径，通过此方法即可实现（由于应用之间分离的，所以各个应用之间互相跳转是会刷新页面的）

## 跨应用之间通信

* 主域名cookie
* url地址传参

建议应该尽可能少地通信，因为这通常会引入不必要的耦合。由于以上是通过二级域名来实现的，如果通过nginx反向代理，则通信的方案就很多了，如：localStorage\sessionstorage\indexedDb\postMessage等。不过这样每次新增都需要配置nginx


大致就想到这些，有一些问题需要后续优化：

* npm仓库中公共模块相互依赖，一个模块更新，需要同步其他各个引用的模块进行更新，目前有一种解决方案lerna。Lerna 是一个用来优化托管在git\npm上的多package代码库的工作流的一个管理工具,可以让你在主项目下管理多个子项目，从而解决了多个包互相依赖，且发布时需要手动维护多个包的问题。具体详细实现仍需调研
* 实现各个子应用跳转整体页面刷新问题
* 各个子组件或者公共库如：vue-cli\vue\vue-router，只需引入一次，后续子项目无需引入？？考虑到这些应用是否可以单独打包编译，部署cdn
* 以上实现方案没有考虑不同框架的兼容。考虑是否可以通过将公共组件打包编译成umd来兼容尼？？
* 工程化问题：npm如何与gitlab集成
* 在每次新增子应用时，都需要同步更新部分公共组件，考虑如何子应用自动注册
